\input texinfo    @c -*-texinfo-*-
%
% sdbfs.in - main file for the documentation
%
%%%%

%------------------------------------------------------------------------------
%
%                         NOTE FOR THE UNAWARE USER
%                         =========================
%
%    This file is a texinfo source. It isn't the binary file of some strange
%    editor of mine. If you want ASCII, you should "make sdbfs.txt".
%
%------------------------------------------------------------------------------

%
% This is not a conventional info file...
% I use three extra features:
%   - The '%' as a comment marker, if at beginning of line ("\%" -> "%")
%   - leading blanks are allowed (this is something I can't live without)
%   - braces are automatically escaped when they appear in example blocks
%

@comment %**start of header
@documentlanguage en
@setfilename sdbfs.info
@settitle sdbfs
@iftex
@afourpaper
@end iftex
@paragraphindent none
@comment %**end of header

@setchapternewpage off

@set update-month September 2012

@finalout

@titlepage
@title SDBFS
@subtitle @value{update-month}
@subtitle A Flash File-system based on SDB data structures
@author Alessandro Rubini for CERN (BE-CO-HT)
@end titlepage
@headings single

@c ##########################################################################
@iftex
@contents
@end iftex

@c ##########################################################################
@node Top
@top Introduction

This package implements and describes a file-system based on the SDB
data structures defined by the Open Hardware Repository project called
@i{Fpga Configuration Space}. The official SDB specification at the time
of this writing is @url{http://www.ohwr.org/attachments/1487/sdb-1.0.pdf}.

The SDB data structures are designed to describe the address space
covered by a bus, which is split in memory regions belonging to
different devices. This project reuses the same structures to describe
a storage address space, exploiting the simple design. While the structures
are not simple to generate, they are very simple to parse, which allows
an embedded processor (like a soft-core running on an FPGA) to access
this filesystem with a minimal amount of code.

@i{sdbfs} is read-only as far as the structure is concerned, but
individual files may be modified if so configured to.  The filesystem
is aware of the concept of block size, so it can be placed on flash
memory, but doesn't do wear-leveling or any other fancy thing to
preserver simplicity.

Currently, the repository is hosted at Gitorious:
@code{git://gitorious.org/rubi/sdbfs.git} but it will likely be merged
into the OHWR project (thus:
@code{git://ohwr.org/hdl-core-lib/fpga-config-space.git}. If you are reading
this document and look for the latest version, if the Gitorious repository
doesn't exist, please try the @i{fpga-config-space} in the OHWR project.

@c ##########################################################################
@node Library Support
@chapter Library Support

@i{No library is there as of this version}.

This package is expected to offer a library of functions to access the
filesystem, but not to create it. Library function should allow
finding a file by name or by vendor/device identifiers, as well as
read and write it.

The library will be based on the concept of @i{driver}, which offers
read and write methods for a specific storage device, and the concept
of @i{instance} of a storage device.

@c ##########################################################################
@node User-Space Tools
@chapter User-Space Tools

Currently, there is only one tool: @i{gensdbfs}.  Later versions will
provide tools to exercise the library function from a host computer,
based on an @i{sdb} image file.

@c ==========================================================================
@node gensdbfs
@section gensdbfs

The tool receives two arguments: the directory to copy into an @i{sdbfs}
image and the name of the image file to be generated.

It accepts the following command line arguments:

@table @code

@item -b <blocksize>

	The block size to be used in generating the file. All files
        and directories are currently aligned to the block size, but
        later versions will not aligned read-only files, to save storage
        space.  The default block size is 64 bytes.

@item -s <devicesize>

	The device size by default is unlimited, internally
        represented by 0. If you specify a device size, @i{gensdbfs} will
        verify that data fits the requested size, and will return an error
        if it doesn't.

@end table

The tool creates an image file that includes the following SDB structures:

@table @i

@item sdb_interconnect

	The structure is used as the first SDB structure of each directory,
        so to include the magic number and the size of the directory. The
        bus type is defined as @i{sdb_data}, with identifier 1. This
        type is not yet part of the official SDB specification.

@item sdb_device

	Every file is instantiated as a device. By being hosted in a
        bus of type @i{sdb_data}, the device is known to be a storage area.

@item sdb_bridge (not yet implemented)

	The @i{bridge} structure is used to represent a subdirectory.

@end table


@c --------------------------------------------------------------------------
@node Use of SDB fields in sdbfs
@subsection Use of SDB fields in sdbfs

The individual fields of the SDB structure are filled in the following way:

@table @code

@item sdb_magic

	In interconnect records, the magic is the standard SDB magic number.
	
@item sdb_version

	1, because this is the SDB version used here.

@item sdb_bus_type

	@code{sdb_data} (added to SDB specification after version 1.0
        of the spec itself).

@item vendor_id

	0x46696c6544617461LL (i.e. @code{"FileData"}). It may be changed
        by the configuration file.

@item device_id

	The first 4 bytes of the file name.  It may be changed
        by the configuration file.

@item version

	Currently 1. Should be the @i{sdbfs} version (git commit).

@item date

	Currently not set. Should be the date when @i{gensdbfs} generated
        the image, in the SDB suggested format.

@item name

	The name is the first 19 character of the original file name,
        padded with blanks (0x20) as per SDB specification. You can't change
        the name using the configuration file.

@item record_type

	@code{sdb_type_interconnect}, for the current directory,
        @code{sdb_type_device} for files and in
        the future @code{sdb_type_bridge} for subdirectories.

@item addr_first

	For a file this is the first byte address where data is found.
        This is currently an absolute address, which makes sense since
        we have no subdirectories yet. However, some use cases require
        the directory information not to live at offset 0, while referring
        to a file that is at the beginning of the storage. SDB mandates
        relative addresses because it's designed for gateware crossbars,
        so we'll have to understand how to deal with this when we have
        subdirectories.   For the directory itself, addr_first is the
        address of the directory -- again, data-before-dir is not cleanly
        handled.

@itemx addr_last

	This is the last allocated byte for files. If the configuration
        file requested extra size for the file, it is accounted here.
        The trailing space is filled with zeroes by @file{gensdbfs} but
        later the configuration file will be able to specify a filler value.
        For directories, this is the last byte written by any files
        within the directory itself.

@item 
@end table

@c --------------------------------------------------------------------------
@node Customizing gensdbfs
@subsection Customizing gensdbfs

If @file{gensdbfs} finds a @code{--SDB-CONFIG--} file in
the toplevel directory, it opens it as a configuration file. Subdirectories
can't have configuration files, as configuration is filesystem-wide.

The file is a text file, line-oriented. Empty lines and comment lines
are ignored. All lines that begin with the hash (@code{#}) are
considered comments (this means that you can't configure a filename
that begins with the hash, but I think this is not a problem.

Configuration values are specified per-file.  Lines that begin with
non-space characters refer to file names. Later indented lines
specify parameters for the current file name.

The following options are supported

@table @code

@item  vendor = <number>

	Change the default vendor value. The value is a 64-bit number and
        can be specified as decimal, hexadecimal or octal.

@item device = <number>

	Change the default device value (the default device is the first
        4 bytes of the file name). The value is a 32-bit number and
        can be specified as decimal, hexadecimal or octal.

@item write = 1

	By default, only world-writable files are generated as writable
        in the filesystem image. This option allows to create a modifiable
        file in the sdb filesystem image without giving over permissions on
        the host filesystem. (You can also use @code{write = 0} to turn
        off write permission).

@item maxsize = <number>

	Specifies the maximum file size. This allows a writeable file to
        be extended in the filesystem image, for later overwriting with
        different data. The program doesn't
        check whether @i{maxsize} is smaller than the current size.
@c FIXME: the maxsize/size issue 

@item position = <number>

	Force the data to be placed at a specific address in the
        filesystem image. For directories, this is the address where
        you'll find the SDB records, whose first 4 bytes are the magic
        number. For files this is the placement of the associated data.
        For all files where @i{position} is not specified, @file{gensdbfs}
        will allocate storage sequentially after the directory itself,
        respecting block alignment.  It's not possible, currently, to
        request all files to be stored sequentially at a specific address

@end table

This package includes a working example in the @file{userspace} directory.
You can thus test the configuration file by running @file{gensdbfs} over
its own source directory.

This is the current content of the file:

@example
   .  
        vendor = 0x123456789abcdef
        device = 257
        position = 0x1000

   Makefile
        position = 0

   gensdbfs.c
        write = 1
        maxsize = 0x10000
@end example

The resulting @i{sdbfs} image will have @code{Makefile} at offset 0,
the directory itself at offset 0x1000 and an area of 64kB of storage
reserved for @code{gensdbfs.c}. The leading part of such are is filled
with the current contents of the file (which is shorter than 64kB).

@c ##########################################################################
@node Kernel Support
@chapter Kernel Support

Kernel support is in the form of a module, which allows drivers to
register (and unregister) storage devices. Each storage device
declares a set of operations to it, so the filesystem can read, erase,
write data independently of the actual storage.  See @i{sdbfs.h} about
data structures and methods. 

Another module, called @i{sdb-fakedev.ko} is provided to allow testing
@i{sdbfs} without real hardware.

@c ==========================================================================
@node sdbfs.ko
@section sdbfs.ko

The filesystem currently only works in read-only mode, and there is no
support for subdirectories.  The @i{name} argument you pass to the
@code{mount} command must match one of the device names that have already
been registered to the filesystem using @code{sdbfs_register_device}.

@c ==========================================================================
@node sdb-fakedev.ko
@section sdb-fakedev.ko

The module receives an array of strings as a parameter called @code{fsimg}.
It supports up to 8 strings: for each of them it calls @code{request_firmware}
and in case of success it registers and @i{sdb} device with the name of
the firmware file.

@c ==========================================================================
@node Example use of kernel code
@section Example use of kernel code

This is an example session that creates, mounts and reads
an @i{sdbfs} image:

@smallexample
    # ls -l userspace
    total 44
    -rw-rw-r-- 1 rubini staff   458 Aug 17 11:33 Makefile
    -rwxrwxr-x 1 rubini staff 20630 Aug 30 13:55 gensdbfs
    -rw-rw-r-- 1 rubini staff  9259 Aug 30 13:55 gensdbfs.c
    -rw-rw-r-- 1 rubini staff   776 Aug 18 06:54 gensdbfs.h
    # userspace/gensdbfs -b 1024 userspace /lib/firmware/stuff.sdb
    # insmod kernel/sdbfs.ko
    # insmod kernel/sdb-fakedev.ko fsimg=stuff.sdb
    # mount -t sdbfs stuff.sdb /mnt
    # ls -l /mnt
    total 0
    -r--r--r-- 1 root root   458 Jan  1  1970 Makefile
    -r--r--r-- 1 root root 20630 Jan  1  1970 gensdbfs
    -r--r--r-- 1 root root  9259 Jan  1  1970 gensdbfs.c
    -r--r--r-- 1 root root   776 Jan  1  1970 gensdbfs.h
    # md5sum /mnt/Makefile userspace/Makefile
    e87991b1c4ac1664327ef388aac4bd71  /mnt/Makefile
    e87991b1c4ac1664327ef388aac4bd71  userspace/Makefile
@end smallexample

@c ==========================================================================
@node Supported kernel versions
@section Supported kernel versions

The current version is a development version only, and as such it has
only been developed and run under Linux-3.4. In the future I'll check
backward portability -- but I'm sure something changed at 3.2 times,
so backward portability will need some work.

@c ##########################################################################
@node Bugs and Missing Features
@chapter Bugs and Missing Features

While the general idea is flying, there are a lot of details that are
still missing. This is just a quick list of things, just off the top
of my head (while looking at the code), sorted by field rather than
priority or complexity:

@itemize

@item gensdbfs: more config file options, like class

@item kernel and gensdbfs: support subdirectories. This is not
trivial because of the relative placement of files within the subdir.

@item kernel: add . and .. entries to readdir

@item kernel: support writing to files

@item kernel: support device access (i.e., a real SDB bus)

@item kernel: read and write bits are not propa

@item lib: everything

@item userspace: tools exercising the library

@item fakedev: show available images in /sys

@item general: factorize some common procedures

@item general: the various FIXME for details in the code itself

@item general: too many printk still in the code

@end itemize


@bye

@c  LocalWords:  Alessandro Rubini CERN iftex texinfo sdbfs gensdbfs devicesize
@c  LocalWords:  blocksize fsimg userspace insmod filesystem gateware
