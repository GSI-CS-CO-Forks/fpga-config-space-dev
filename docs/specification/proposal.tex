\documentclass[a4paper, 12pt]{article}

\usepackage{draftwatermark}
\usepackage{changepage}
%\usepackage{fullpage}
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{array}
\usepackage{multirow}
\usepackage{footnote}
\usepackage{graphicx}
\usepackage{verbatim}

\SetWatermarkScale{4}
%\SetWatermarkText{beta version}
\SetWatermarkLightness{0.9}

\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\lstset{
	tabsize=4,
	basicstyle=\footnotesize,
	columns=fixed,
}

\parindent0pt
\parskip10pt
\makesavenoteenv{tabular}

\title{Self Description Structures for Logic Cores}
\author{Manohar Vanga (BE/CO/HT), Wesley Terpstra (GSI),\\
Alessandro Rubini (Independent Consultant)}
\date{June 13th 2012}
\begin{document}

\maketitle

\tableofcontents
\listoftables
\listoffigures

\pagebreak

\section{Introduction}

This document describes a specification for a series of self description
structures that can be used to provide metadata about logic blocks. This metadata
should be provided by the logic cores, like PCI or USB description records,
so device drivers and other software can automatically discover the blocks and
configure them during runtime.

\subsection{History and Rationale}

The idea of a self-describing bus appeared while working on
\textit{White Rabbit} and related projects that make massive use of
FPGA devices. Separately and concurrently, both the CERN and the GSI
working groups identified the need for some way to self-detect the
contents of a specific logic device after it is programmed.

We envisioned that if the internal FPGA bus could enumerate its own
content, we would get the following advantages:

\begin{itemize}
\item Run-time validation of FPGA binary images;
\item Easy matching of software and gateware;
\item Automatic handling of several binaries with the same software;
\item Feasibility of tools similar to \texttt{lspci} and \texttt{lsusb};
\item Automatic loading of kernel drivers on the host computer;
\item Automatic setup of low-level driver within soft cores;
\item Better decoupling of gateware and software development.
\end{itemize}

As usual in engineering, we wanted a system that was as simple as possible,
yet open to future extensions without introducing compatibility issues.
While our internal bus is \textit{Wishbone}, we designed the structures
to be generic so other bus implementations may use them. 

We are aware of the AMBA (PrimeCell) cell-id standard, but we think it
is seriously under-designed: the idea is sound, but a single cell-ID field
is not enough if we want to make sense of the whole bus. We think current
hardware and software resources allow a richer description of logic blocks.

We are also aware of the PCI and USB data structures, but they are
unsuitable for an FPGA, either. First of all, they assume devices are
enumerated by other means whereas we need to be able to scan a flat
address space; then, their vendor ID space is ridiculously small
because the model of the respective consortia is based on artificial scarcity.

This specification, thus, uses 64 bits for the vendor ID, to prevent scarcity.
The vendor space is spit in two parts, and everybody is free to elect their
own vendor number and start designing using the spec, provided the most-significant
bit is set.

We acknowledge the usefulness of a central vendor registry, so
the lower half of the
vendor-ID space is reserved for numbers that
are officially assigned and published.  The vendor registry, however, is not
part of this specification, which just lists the first few vendor-ID values that
have already been used.

All multi-byte values are stored in \textit{big endian} order.  This
choice is designed to make the life easier some developers (the poor
guys that sometimes need to look at binary dumps one byte at a time)
and to make life harder for other developers (the poor guys that work
on the PC and think all the world is \textit{little endian}).  Actually,
by choosing the less common endianness we think it's easier to write
portable code, because code ignoring byte ordering will simply not work
when compiled on the PC.

All data structures are 64 byte large and are similar in their
internal layout; the last byte in the 64-wide slot identifies the type
of each structure, to allow very simple parsing code and easy extension
to new types of structures.  The size is a power of two in order to
avoid multiplication and division in calculation of sizes, as the
driver may reside in a very simple soft-core.


\subsection{Scope of This Specification}

This specification is not \textit{official} in any way: it just
documents what we are doing and why we do it like this.  We believe
in free circulation of ideas and we think the good ones will flourish.
Everybody is welcome to use the data structures defined  in this specification
and give feedback, both positive and negative.

The document (with the notable exception of this section) is written
as a formal specification because we need clear and sharp rules in
order to make different implementations interoperate.  We are sticking
to those rules in our own implementations, both in gateware and in
associated software.

Everybody is free to choose a vendor-ID and start coding right now; we
suggest to pick a random 64 bit number and set the most significant
bit (as an alternative, you can pick a random 63 bit number and
concatenate it to a single set bit).

If you want to implement your own data structures, similar to ours
but different in some way, please change the magic number, to avoid
headaches if both bus implementation are instantiated within the same host
computer or network.

\subsection{The Overall System Structure}

The bus described by the structures defined herein is set up as a
flat address space. Our initial target is the \textit{Wishbone} bus,
as used in our own FPGA projects, but the overall situation is
pretty general and can be applied to any bus or even a storage
system for quasi-static information in flash memory

To keep variety to a minimum, this standard defines the concept of
\textit{product}, which is (anything that has been \textit{done}, and thus has
its own identifiers, name, version and date).  This includes
meta-information, for example a record of the final build of the
FPGA binary.

Every \textit{product} that owns some address space is called a
\textit{component}; as such it specifies its first and last address, as
64 bit numbers.

Within the bus memory area, the address space available to bus masters
is usually decoded into several blocks using the high address bits, so
that the space is divided into several blocks, usually they are sized
as powers of two, but this is not mandatory -- some designers may use
individual address lines to select blocks, to easily get a sparsely
populated address space.  The designer of the address demultiplexer
(the \textit{interconnect} block) is expected to describe the
logic blocks living behind the interconnect, as well as the
interconnect itself. Thus, the \textit{interconnect} is a \textit{component}
(it has an address range), and the associated structure is the first
one of an array of structures, that defines components and optionally
more abstract products.

Some of the blocks within an interconnect data space can in turn be
bridges to another interconnect device.  Thus, the \textit{bridge}
component states where he further self-description structures are to
be found. This allows nesting at arbitrary levels (too deep nesting is
not a good practice, but the specification is not limiting the
designer ingenuity).

Only the bus designer knows where the outer-level data structure is to
be found, and such information is expected to be known by the ``bus
driver'' software package.  For example, a soft-core scanning its own
bus will know where to start from, because it is part of the same
overall design; a PCI driver must know how to access internal bus
memory from a PCI memory window, so it can also know where the
self description entry point is stored; an \textit{Etherbone} bus master will
comply to its own packet-format standard, so it can as well know
where to start enumerating the bus from.

We can therefore define the following terms to build the
self-description framework:

\begin{description}
\item[Product] \hfill \\
Every structure includes \textit{product} fields. They are
the vendor and device identifiers, version and date, an UTF-8
name.

\item[Component] \hfill \\
A component is a product with an associated address range. Its
structure lists the first and last valid addresses within
the encompassing address space.

\item[Interconnect] \hfill \\
The interconnect is a component representing an address demultiplexer.
The associated data structure heads an array of product descriptions,
it features a magic number, bus type, version and the number of
structures in the array.

\item[Device] \hfill \\
The device component identifies a peripheral block, with
its class, ABI version and bus-specific flags.

\item[Bridge] \hfill \\
The bridge component marks a memory area leading to a lower-level
address demultiplexer (i.e. \textit{interconnect}). Its data
structure declares the address where the self-description of the
sub-bus is found.

\item[Integration] \hfill \\
The optional integration product describes the aggregate bus.
It is a \textit{product} record, not a
\textit{component}, so it has no associated address range. This
meta-information item can be used by a vendor using a standard
\textit{interconnect} logic block to declare its own
identifiers and integration date for the whole FPGA design; as
such we expect to find it only in the description of the
outer bus description level.

\item[Controller] \hfill \\
The \textit{controller} is a software abstraction, used in the host
computer driving the bus (if any). The controller defines the
methods to access its own bus and knows where the outer description
array is found.  There is no controller concept for soft-cores
self-scanning their own address space.

\end{description}

\subsection{Current Implementations}

The self-description mechanisms described here are already
successfully used by the Etherbone project, whereas FPGA devices
equipped with an Ethernet port allow external hosts to be bus masters
in the internal Wishbone bus.  The host computer can completely
describe and access the remote bus(es) using the structures described
here; by identifying each instantiated device it can also drive the
remote peripherals without prior knowledge of the specific FPGA binary
it is talking to.

The same mechanism is soon going to be used in the \textit{White
Rabbit PTP Core} and the outer-level FPGA designs that are
being used in our synchronized I/O boards.

\section{SDB Header Material}

This section includes the whole header file that defines the data
structures. The header is also part of the source code accompanying
this specification.

All fields and bits are explained in detail in later sections of this
specification, but we prefer to show the meat straight at the
beginning, before being lost in acronyms and gory details.

This header uses the Linux kernel coding style (e.g.: no \texttt{typedef} is used),
but you can write it differently if you prefer -- some of us already did -- as
long as the binary representation of the data matches this one.

\footnotesize
\verbatiminput{sdb-h.expand}
\normalsize

\section{SDWB Structures}

This section describes the important structures that are a part of the SDWB specification.

\subsection{SDWB Table}

The most important structure that needs to be present in a design to support SDWB
based autodiscovery is the SDWB table.

The SDWB table is a contiguous array of records that provides the needed metadata
about devices. There is no restriction placed on where this table is located in
memory and the higher levels only need to know the location of the top-level table
to recursively discover the descriptions of all the blocks.

An SDWB table is composed of multiple SDWB records. There are four different types of
SDWB records that can be used to describe different parts of the design.

\begin{enumerate}
\item Interconnect Record
\item Device Record
\item Bridge Record
\item Integrator Record
\end{enumerate}

\subsection{SDWB Product Info}

The SDWB product info structure is a 40 byte structure that provides information about
the specific product being described. The information provided here is used for device
identification.

\begin{center}
  \begin{savenotes}
    \begin{table}[!ht]\footnotesize
      \caption{SDWB Product Info Structure (40 bytes)}\label{sdwb_product_struct}\centering
        \begin{tabular}{| c | c | l | c | p{5cm} |} \hline
        Offset & Size (bytes) & Name & Value & Description \\ \hline
        0x00 & 8 & VENDOR\_ID & - & 64-bit vendor ID \\ \hline
        0x08 & 4 & DEVICE\_ID & - & 32-bit vendor specific device ID \\ \hline
        0x0C & 4 & VERSION & - & Vendor specific device version number \\ \hline
        0x10 & 4 & DATE & - & The release date (hex format, eg. 0x20120601) \\ \hline
        0x14 & 19 & NAME & - & ASCII device name without NULL terminator \\ \hline
        0x27 & 1 & RECORD\_TYPE & - & Record type byte (see Table \ref{record_type}) \\ \hline
        \end{tabular}
    \end{table}
  \end{savenotes}
\end{center}

\begin{description}
\item[VENDOR\_ID] \hfill \\
This field provides a 64 bit field that identifies the vendor of the device. The vendor may
be an company, organization or an individual. The size of this field has been kept at 64
bits to prevent collisions in the long term.

A registry is still needed to prevent collisions when using community developed designs from
multiple sources and one will be set up in the near future. However, use of the registry is
not mandated. To allow for this, the 64 bit ID space is split into two parts. All ID's with
the most significant bit set are considered free to use. No guarantees are provided regarding
collisions when using this space during integration of designs with externally provided
components.

The second part of the ID space with the most significant bit unset is reserved for use with
the registry.

\item[DEVICE\_ID] \hfill \\
This field specifies a manufacturer defined device ID for the device being described.

\item[VERSION] \hfill \\
This field specifies a manufacturer defined version number for the device. For example, this
may be derived from the information provided by the source code management being used.

\item[DATE] \hfill \\
This field specified the release date of the device being described. This must be a 32-bit hex
format number in the format 0xYYYYMMDD. For example, 0x20120101 specifies the first day of the
year 2012.

\item[NAME] \hfill \\
The ASCII name of the device. No NULL terminator need be provided in this field. The name length
may be a maximum length of 19 characters. Unused bytes should be set to 0x20 (or ASCII SPACE).

\item[RECORD\_TYPE] \hfill \\
Since the product info structure is embedded within various types of record structures, this
field specifies the type of the encapsulating structure. There is a record type for each kind
of SDWB record as well as one to specify an empty record. The various record types are described
in Table \ref{record_type}.

\begin{center}
  \begin{savenotes}
    \begin{table}[!ht]\footnotesize
      \caption{SDWB Record Types}\label{record_type}\centering
        \begin{tabular}{| c | l | p{5cm} |} \hline
        Name & Value & Description \\ \hline
        INTERCONNECT & 0x00 & Interconnect record type \\ \hline
        DEVICE & 0x01 & Device record type \\ \hline
        BRIDGE & 0x02 & Bridge record type \\ \hline
        INTEGRATOR & 0x80 & Integrator record type \\ \hline
        EMPTY & 0xFF & Empty record type \\ \hline
        \end{tabular}
    \end{table}
  \end{savenotes}
\end{center}
\end{description}

\subsection{SDWB Component Info}

The Component Info structure is a 56 byte structure which, in addition to embedding product
information, also additionally provides information regarding the address space used by the
device. When a particular record type requires address space information in addition to product
information, this structure is embedded.

\begin{center}
  \begin{savenotes}
    \begin{table}[!ht]\footnotesize
      \caption{SDWB Component Info Structure (56 bytes)}\label{sdwb_component_struct}\centering
        \begin{tabular}{| c | c | l | c | p{5cm} |} \hline
        Offset & Size (bytes) & Name & Value & Description \\ \hline
        0x00 & 8 & ADDR\_BEGIN & - & The start address of the component \\ \hline
        0x08 & 8 & ADDR\_LAST & - & The last valid address of the component \\ \hline
        0x10 & 40 & PRODUCT & - & SDWB Product Info structure (see Table \ref{sdwb_product_struct} \\ \hline
        \end{tabular}
    \end{table}
  \end{savenotes}
\end{center}

\begin{description}
\item[ADDR\_BEGIN] \hfill \\
The start address of the memory area occupied by the device.

\item[ADDR\_LAST] \hfill \\
The last valid address in memory that is occupied by the device. For example, a device that takes
up the entire 64-bit space has its last address at 0xffffffffffffffff

\item[PRODUCT] \hfill \\
This is the embedded 40 byte product info structure as described in Table \ref{sdwb_product_struct}.
\end{description}

\subsection{SDWB Records}

This subsection describes the different SDWB records that compose the SDWB table structure. These
structures must be instantiated by designers for each logic block in their design and compiled into
a contiguous SDWB table that gets placed in the bus memory.

\subsubsection{Interconnect Record}

The interconnect record describes the high level bus that has child devices connected to it. This
structure should be the "header" or first record in the SDWB table. It provides, among other things,
information regarding the SDWB table (eg. the number of following records).

\begin{center}
  \begin{savenotes}
    \begin{table}[!ht]\footnotesize
      \caption{SDWB Interconnect Record Structure}\label{sdwb_interconnect_struct}\centering
        \begin{tabular}{| c | c | l | c | p{5cm} |} \hline
        Offset & Size (bytes) & Name & Value & Description \\ \hline
        0x00 & 4 & MAGIC & 0x53445742 & Magic value for checking validity \\ \hline
        0x04 & 2 & NUM\_RECORDS & - & Number of records in this SDWB table \\ \hline
        0x06 & 1 & SDWB\_VERSION & 0x1 & SDWB format version. Current is 0x1 \\ \hline
        0x07 & 1 & SDWB\_BUS\_TYPE & - & The last valid address of the component \\ \hline
        0x08 & 56 & COMPONENT & - & SDWB Component Info structure (see Table \ref{sdwb_component_struct} \\ \hline
        \end{tabular}
    \end{table}
  \end{savenotes}
\end{center}

\begin{description}
\item[MAGIC] \hfill \\
This field is a unique number to ensure that the record being read is valid. The default
value for this in this version of the specification is 0x53445742 or the ASCII characters
"SDWB".

\item[NUM\_RECORDS] \hfill \\
This field specifies the number of records in the table. The number must take into account
this header (interconnect) record as well. The other records following the header may be
any combination of device, bridge and integrator records.

\item[SDWB\_VERSION] \hfill \\
This is the record format version. In the current version of the specification this is the
value 0x1.

\item[SDWB\_BUS\_TYPE] \hfill \\
This field specifies the bus type. This field is used when decoding the bus specific information
inside a device record (see below). In the current version of the specification, the only
supported bus is Wishbone. Other buses may be added in the future.

\begin{center}
  \begin{savenotes}
    \begin{table}[!ht]\footnotesize
      \caption{SDWB Bus Types}\label{bus_type}\centering
        \begin{tabular}{| c | l | p{5cm} |} \hline
        Name & Value & Description \\ \hline
        WISHBONE & 0x00 & Specifies a Wishbone bus type \\ \hline
        \end{tabular}
    \end{table}
  \end{savenotes}
\end{center}

\item[COMPONENT] \hfill \\
An interconnect record has a component info structure embedded within it which can be used
to provide additional meta-data regarding the interconnect itself.
\end{description}

\subsubsection{Integrator Record}

An integrator record gives meta-data about the aggregate product of the bus. For example, consider
a manufacturer that takes components from various vendors and combines them with a standard bus
interconnect. This aggregate product can be described by an SDWB integrator record.

This record is important as it helps to clearly distinguish product information of devices and of
their aggregated products. Since this is the only main requirement of the integrator record, it
only contains a product info structure without the additional address space information (as this
can easily be gleaned from the records for the specific devices that compose the aggregate). The
structure of the integrator record is described in Table \ref{sdwb_integrator_struct}.

\begin{center}
  \begin{savenotes}
    \begin{table}[!ht]\footnotesize
      \caption{SDWB Integrator Record Structure}\label{sdwb_integrator_struct}\centering
        \begin{tabular}{| c | c | l | c | p{5cm} |} \hline
        Offset & Size (bytes) & Name & Value & Description \\ \hline
        0x00 & 24 & RESERVED & - & Reserved bytes \\ \hline
        0x18 & 40 & PRODUCT & - & SDWB Product Info structure (see Table \ref{sdwb_product_struct} \\ \hline
        \end{tabular}
    \end{table}
  \end{savenotes}
\end{center}

\begin{description}
\item[PRODUCT] \hfill \\
An integrator record has a product info structure embedded within it which can be used
to provide meta-data that aids in identifying the aggregating interconnect.
\end{description}

\subsubsection{Device Record}

This record type describes a single device or logic block mapped into the memory of the
bus. In a correct implementation, one device record should exist for each device that is
connected to the bus. The structure of the device record structure is shown below in Table
\ref{sdwb_dev_struct}.

\begin{center}
  \begin{savenotes}
    \begin{table}[!ht]\footnotesize
      \caption{SDWB Device Record Structure}\label{sdwb_dev_struct}\centering
        \begin{tabular}{| c | c | l | c | p{5cm} |} \hline
        Offset & Size (bytes) & Name & Value & Description \\ \hline
        0x00 & 2 & ABI\_CLASS & - & The ABI class of the device (0 = Custom Device) \\ \hline
        0x02 & 1 & ABI\_VER\_MAJOR & - & The ABI major version \\ \hline
        0x03 & 1 & ABI\_VER\_MINOR & - & The ABI minor version \\ \hline
        0x04 & 4 & BUS\_SPECIFIC & - & Bus specific field \\ \hline
        0x08 & 56 & COMPONENT & - & SDWB Component Info structure (see Table \ref{sdwb_component_struct} \\ \hline
        \end{tabular}
    \end{table}
  \end{savenotes}
\end{center}

\begin{description}
\item[ABI\_CLASS] \hfill \\
The ABI class, if specified, tells the kind of standard interface that the device provides. The
currently available types of ABI classes are specified in Table \ref{abi_class_list}.

\begin{center}
  \begin{savenotes}
    \begin{table}[!ht]\footnotesize
      \caption{ABI Classes}\label{abi_class_list}\centering
        \begin{tabular}{| c | l | p{5cm} |} \hline
        Value & ABI Class & Description \\ \hline
        0 & Custom Device & Used when the device does not conform to any standard interface \\ \hline
        \end{tabular}
    \end{table}
  \end{savenotes}
\end{center}

\item[ABI\_VER\_MAJOR] \hfill \\
This is the major version number of the ABI class. Standard interfaces are not compatible between
major version changes.

\item[ABI\_VER\_MINOR] \hfill \\
This is the minor version number of the ABI class. Standard interfaces are compatible between
minor version changes.

\item[BUS\_SPECIFIC] \hfill \\
This is a 4-byte field that holds bus-specific information. The bus specific information for different
supported buses is described in Table \ref{bus_specific}.

\begin{center}
  \begin{savenotes}
    \begin{table}[!ht]\footnotesize
      \caption{Wishbone -- Bus Specific Information}\label{bus_specific}\centering
        \begin{tabular}{| c | l | p{5cm} |} \hline
        Bit Offset & Name & Description \\ \hline
        0 & ENDIAN & Specifies the endianness of the device (0 = big endian, 1 = little endian) \\ \hline
        \end{tabular}
    \end{table}
  \end{savenotes}
\end{center}

\item[COMPONENT] \hfill \\
An embedded component info structure for providing meta-data about the device being described.
\end{description}

\subsubsection{Bridge Record}

A bridge record is used to describe a nested bus within the same address space. This is different from
a bus controller which provides access to an entirely different address space altogether. Bus
controllers should be treated and handled as devices and not bridges. The structure of the bridge record
is shown in Table \ref{sdwb_bridge_struct}.

\begin{center}
  \begin{savenotes}
    \begin{table}[!ht]\footnotesize
      \caption{SDWB Bridge Structure}\label{sdwb_bridge_struct}\centering
        \begin{tabular}{| c | c | l | c | p{5cm} |} \hline
        Offset & Size (bytes) & Name & Value & Description \\ \hline
        0x00 & 8 & SDWB\_CHILD & - & The relative address of the nested SDWB table \\ \hline
        0x08 & 56 & COMPONENT & - & SDWB Component Info structure (see Table \ref{sdwb_component_struct} \\ \hline
        \end{tabular}
    \end{table}
  \end{savenotes}
\end{center}

\begin{description}
\item[SDWB\_CHILD] \hfill \\
This field gives the location of the nested bus' SDWB table. This address is a relative address
with respect to the start of the nested bus' address space (stored in the component info structure).

\item[COMPONENT] \hfill \\
An embedded component info structure for providing meta-data about the bridge being described.
\end{description}

\end{document}
