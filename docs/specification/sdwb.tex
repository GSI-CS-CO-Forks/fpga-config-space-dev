\documentclass{article}

\usepackage{fullpage}
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{array}
\usepackage{multirow}
\usepackage{footnote}
\usepackage{graphicx}

\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\lstset{
	tabsize=4,
	basicstyle=\footnotesize,
	columns=fixed,
}

\parindent0pt
\parskip10pt
\makesavenoteenv{tabular}

\title{Self Descriptive Structures for Logic Cores}
\author{Manohar Vanga (BE/CO/HT), Alessandro Rubini (University of Pavia)}
\date{22 June 2011}
\begin{document}

\maketitle

\tableofcontents
\listoftables
\listoffigures

\pagebreak

\section{Introduction}

This document describes a specification for a series of self descriptive
structures that can be used to provide metadata about logic blocks, thus
allowing for upper level abstractions to automatically discover the blocks.

\subsection{Requirements}

The specification designed in this document has been designed with keeping
the following points in mind.

\begin{itemize}
\item Provide support for flexibly defining devices ranging from large and
verbose descriptors to small and efficient ones.
\item Allow for the integration of firmware level metadata into the structures.
This includes information like firmware version and synthesis date.
\item Support for heirarchical definitions where devices express parent-child
relationships.
\item Provide support for proprietary blocks that cannot be modified at the
source level and can possibly contain entire device heirarchies.
\item There should be a minimal sets of constraints placed on designers and
integrators in terms of how and where they can map their designs in memory.
\item There should be no forcible use of external metadata. Relying on external
information quickly leads to outdated and mismatched metadata.
\item Structures should be space efficient and provide support for a wide range
of hardware ranging from the small to the highly complex.
\end{itemize}

\subsection{Definitions}
\begin{description}
  \item[Logic Blocks] \hfill \\
    Logic blocks refer to specific logic written in a high level hardware-description
    language. These are also referred to as IP cores.
  \item[Bitstream] \hfill \\
    The compiled binary version of a complete HDL design, possibly consisting of
    multiple interconnected logic blocks, is referred to as a bitstream in this
    document.
  \item[Designer] \hfill \\
    In this document, the term designer refers to the person who authors logic
    blocks in a hardware description language.
  \item[Integrator] \hfill \\
    In this document, the term integrator refers to the person who is responsible
    for taking a set of logic blocks and connecting them together to create the
    final topology of the bistream.
\end{description}

\pagebreak

\section{Structures}

The structures of the specification are separated into block descriptive
structures and topology descriptive structures.

Block descriptive structures are used to describe device information that
is static. Examples of information that resides in block descriptive
structures are device and vendor identifiers. This allows manufacturers to
fix this information into logic blocks before distribution and not worry
about providing the ability to modify the contents.

Topology descriptive structures are used to describe the topology of blocks
within an address space. These contain information that is defined by the
integrator or designer who describes the high level topology of multiple
logic blocks in a hierarchy. An example of information that resides in
topology descriptive structures is the base address of a logic block in a
mapped address space.

The following are the block descriptive structures that are a part of this
specification.

\begin{itemize}
\item Device descriptor blocks
\end{itemize}

The following are the topology descriptive structures that are a part of this
specification.

\begin{itemize}
\item Header blocks
\item ID blocks
\item Child pointer blocks
\end{itemize}

All structures contain variations on the address size to support constrained
devices. The available address sizes in the current specification are 64, 32
and 16 bits.

The following points should be noted:

\begin{itemize}
\item All values are big-endian. This has been chosen as it facilitates easy
human readability of the values. This is true of all values within structures
and should be adhered to carefully.
\item The presence of 64 bit registers within certain structures does not imply
the requirement for a 64 bit wide data bus. Multiple reads can be done using a
smaller data bus width (eg. 2 reads on a 32 bit data bus).
\item The maximum address width is currently 64 bits. While buses such as Wishbone
allow for a theoretically infinite address space, we have stayed within current
practical limits for this. In future versions, this may be increased based on
volatile requirements. This expasibility has been kept in mind throughout the
design of this specification.
\item It is entirely the choice of the designer to choose what size descriptor set
they wish to use for their logic blocks. It is entirely feasible to use a 64 bit
descriptor set for a device that only needs 16 bits of address space.
\end{itemize}

\subsection{Header Blocks}

The header blocks are simple structures that contains the locations of a top-level
child pointer block (see Section \ref{}) and an ID block (see Section \ref{}).

Header blocks can be placed at any location within an address space
as long as the location can be found in some way (eg. a constant in HDL).
It is recommended that the address of the header be placed into memory
within the parent bus. For example, a BAR can be used in the case of PCI,
the CR/CSR space in the case of VME and the configuration space in the case
of Etherbone.

\subsubsection{LCSD64 Header Block}
The LCSD64 header block is the one used in a 64 bit address space. The structure
of the LCSD64 header block is described in Table \ref{hdr_block_struct}.

\begin{center}
  \begin{savenotes}
    \begin{table}[!ht]\footnotesize
      \caption{LCSD64 header block structure}\label{hdr_block_struct}\centering
      \begin{tabular}{| c | c | l | c | c | p{5cm} |} \hline
      Offset & Size (in bytes) & Name & Access & Value & Description \\ \hline
      0x00 & 0x08 & MAGIC & RO & 0x5344574248454144LL & Magic number used to ensure that there is a valid header present. \\ \hline
      0x08 & 0x08 & ID\_BLOCK\_ADDR & RO & - & Address of the ID block. See section \ref{id_block} for more information. \\ \hline
      0x10 & 0x08 & TLCP\_BLOCK\_ADDR & RO & - & Address of the top-level child pointer block. See section \ref{child_pointer_block} for more information. \\ \hline
      \end{tabular}
    \end{table}
  \end{savenotes}
\end{center}

\begin{description}
\item[MAGIC] \hfill \\
This field contains a unique value that allows software to ensure that
the header contains valid data. If the magic number does not match the
expected value, the software should abort.

The magic number in the current version of the specification is expected to
be 0x5344574248454144 or the ASCII string "SDWBHEAD" (big-endian) without the
string terminator.

\item[ID\_BLOCK\_ADDR] \hfill \\
This field contains the address of the ID block in the memory space (see Section
\ref{id_block} for more information).

\item[TLCP\_BLOCK\_ADDR] \hfill \\
This field contains the address of the top level child pointer block (see Section
\ref{tlcp_block} for more information).
\end{description}

\subsubsection{LCSD32 Header Block}
The LCSD32 header block is the one used in a 32 bit address space. The structure
of the LCSD32 header block is described in Table \ref{hdr_block_struct}.

\begin{center}
  \begin{savenotes}
    \begin{table}[!ht]\footnotesize
      \caption{LCSD32 header block structure}\label{hdr_block_struct}\centering
      \begin{tabular}{| c | c | l | c | c | p{5cm} |} \hline
      Offset & Size (in bytes) & Name & Access & Value & Description \\ \hline
      0x00 & 0x08 & MAGIC & RO & 0x5344574248454144LL & Magic number used to ensure that there is a valid header present. \\ \hline
      0x08 & 0x04 & ID\_BLOCK\_ADDR & RO & - & Address of the ID block. See section \ref{id_block} for more information. \\ \hline
      0x0c & 0x04 & TLCP\_BLOCK\_ADDR & RO & - & Address of the top-level child pointer block. See section \ref{child_pointer_block} for more information. \\ \hline
      \end{tabular}
    \end{table}
  \end{savenotes}
\end{center}

\begin{description}
\item[MAGIC] \hfill \\
This field contains a unique value that allows software to ensure that
the header contains valid data. If the magic number does not match the
expected value, the software should abort.

The magic number in the current version of the specification is expected to
be 0x5344574248454144 or the ASCII string "SDWBHEAD" (big-endian) without the
string terminator.

\item[ID\_BLOCK\_ADDR] \hfill \\
This field contains the address of the ID block in the memory space (see Section
\ref{id_block} for more information).

\item[TLCP\_BLOCK\_ADDR] \hfill \\
This field contains the address of the top level child pointer block (see Section
\ref{tlcp_block} for more information).
\end{description}

\subsubsection{LCSD16 Header Block}
The LCSD16 header block is the one used in a 16 bit address space. The structure
of the LCSD16 header block is described in Table \ref{hdr_block_struct}.

\begin{center}
  \begin{savenotes}
    \begin{table}[!ht]\footnotesize
      \caption{LCSD16 header block structure}\label{hdr_block_struct}\centering
      \begin{tabular}{| c | c | l | c | c | p{5cm} |} \hline
      Offset & Size (in bytes) & Name & Access & Value & Description \\ \hline
      0x00 & 0x08 & MAGIC & RO & 0x5344574248454144LL & Magic number used to ensure that there is a valid header present. \\ \hline
      0x08 & 0x02 & ID\_BLOCK\_ADDR & RO & - & Address of the ID block. See section \ref{id_block} for more information. \\ \hline
      0x0c & 0x02 & TLCP\_BLOCK\_ADDR & RO & - & Address of the top-level child pointer block. See section \ref{child_pointer_block} for more information. \\ \hline
      0x0c & 0x04 & RESERVED & RO & - & Reserved \\ \hline
      \end{tabular}
    \end{table}
  \end{savenotes}
\end{center}

\begin{description}
\item[MAGIC] \hfill \\
This field contains a unique value that allows software to ensure that
the header contains valid data. If the magic number does not match the
expected value, the software should abort.

The magic number in the current version of the specification is expected to
be 0x5344574248454144LL or the ASCII string "SDWBHEAD" (big-endian) without the
string terminator.

\item[ID\_BLOCK\_ADDR] \hfill \\
This field contains the address of the ID block in the memory space (see Section
\ref{id_block} for more information).

\item[TLCP\_BLOCK\_ADDR] \hfill \\
This field contains the address of the top level child pointer block (see Section
\ref{tlcp_block} for more information).
\end{description}

\subsection{ID Block}\label{id_block}

The ID block contains information that uniquely identifies the bitstream
within the FPGA.

The ID block additionally contains information about the parent board.
This information allows clients unable to access the parent bus memory
to know the metadata of the hardware they are accessing.

The structure of the ID block is described in Table \ref{id_block_struct}.

\begin{center}
	\begin{savenotes}
	\begin{table}[!ht]\footnotesize
	\caption{Wishbone ID block structure}\label{id_block_struct}\centering
	\begin{tabular}{| l | c | l | c | c | p{5cm} |} \hline
	Offset & Size (in bytes) & Name & Access & Value & Description \\ \hline
	0x00 & 0x08 & BSTREAM\_DEVTYPE & RO & - & The bitstream type identifier. \\ \hline
	0x08 & 0x04 & BSTREAM\_VERSION & RO & - & The version of the specific bitstream. \\ \hline
	0x0C & 0x04 & BSTREAM\_DATE & RO & - & The synthesis date of the bitstream. \\ \hline
	0x10 & 0x10 & BSTREAM\_SOURCE & RO & 0x0 & The SVN revision number or the SHA-1 hash of the Git release (first 16 bytes). \\ \hline
	\end{tabular}
	\end{table}
	\end{savenotes}
\end{center}

\begin{description}
\item[BSTREAM\_DEVTYPE (Offset: 0x00)] \hfill \\
The bitstream device type should hold a value that uniquely identifies the type of 
bitstream present in the FPGA. Note that different bitstreams can have the
same type with differing versions (see below).

\item[BSTREAM\_VERSION (Offset: 0x08)] \hfill \\
The bitstream version should hold a value that specifies the version of the
bitstream present in the FPGA. This field along with the BSTREAM\_DEVTYPE field,
should uniquely identify a specific bitstream.

\item[BSTREAM\_DATE (Offset: 0x0C)] \hfill \\
The bitstream date should be set to the hex-readable date of synthesis of
the bitstream. An example of a hex-readable date is 0x20111225 (25th December
2011).

\item[BSTREAM\_SOURCE (Offset: 0x10)] \hfill \\
This field should specify an identifier for the revision control software
used to manage the HDL code for the bitstream type. This allows for the 
possibility of automatic checking out and loading of bitstreams.

In the case of SVN repositories, the value of the revision number should
be stored in this field. For example, if the SVN revision is 1024, the 
stored value should be 0x400.

In the case of Git repositories, the first 16 bytes (0x10 bytes) of the
160 bit (20 bytes, 0x14 bytes) value of the commit hash should be stored
in this field.

\end{description}

\subsection{Device Descriptor Block}\label{device_block}

The device descriptor block describes all the Wishbone peripherals present
on the bus. The block is made of an array of device descriptors which have
a structure as described in Table \ref{dev_desc_struct}.

\begin{center}
	\begin{savenotes}
	\begin{table}[!ht]\footnotesize
	\caption{Wishbone device descriptor structure}\label{dev_desc_struct}\centering
	\begin{tabular}{| l | c | l | c | c | p{5cm} |} \hline
	Offset & Size (in bytes) & Name & Access & Value & Description \\ \hline
	0x00 & 0x08 & VENDOR & RO & - & The vendor ID of the vendor of the Wishbone device. \\ \hline
	0x08 & 0x04 & DEVICE & RO & - & The device ID of the Wishbone device. \\ \hline
	0x0C & 0x02 & WBD\_MAGIC & RO & 0x5742 & Magic number used to identify a valid device descriptor. \\ \hline
	0x0E & 0x01 & WBD\_VER\_MAJOR & RO & - & The major version of the descriptor format. \\ \hline
	0x0F & 0x01 & WBD\_VER\_MINOR & RO & - & The minor version of the descriptor format. \\ \hline
	0x10 & 0x08 & HDL\_BASE & RO & - & Base address (Wishbone) of the Wishbone device. \\ \hline
	0x18 & 0x08 & HDL\_SIZE & RO & - & Size (in bytes) of the device address space. \\ \hline
	0x20 & 0x04 & WBD\_FLAGS & RO & 0x0 & Device flags. \\ \hline
	0x24 & 0x04 & HDL\_CLASS & RO & - & HDL class. \\ \hline
	0x28 & 0x04 & HDL\_VERSION & RO & - & HDL version. \\ \hline
	0x2C & 0x04 & HDL\_DATE & RO & - & HDL generation date. \\ \hline
	0x30 & 0x10 & VENDOR\_NAME & RO & - & Vendor name (ASCII string) \\ \hline
	0x40 & 0x10 & DEVICE\_NAME & RO & - & Device name (ASCII string) \\ \hline
	\end{tabular}
	\end{table}
	\end{savenotes}
\end{center}

\begin{description}
\item[VENDOR (Offset: 0x00)] \hfill \\
The vendor ID of the Wishbone device.

\item[DEVICE (Offset: 0x08)] \hfill \\
The device ID of the Wishbone device. Together with the vendor ID, the
device ID may be used to match device drivers. The format can be specified
in any way by a vendor as the software reading this field will be
specific to each vendor (selected based on the metadata stored in the
parent board) and is expected to know how to decode this field.

\item[WBD\_MAGIC (Offset: 0x0C)] \hfill \\
This is a unique value used to identify a valid Wishbone device structure. If
an invalid magic value is found, it is assumed that there are no more devices
to be discovered and the auto-discovery is ended. Thus, it is used as the array
terminator for the Wishbone device block.

The magic number in all versions of the specification can be expected to
be 0x5742 or the ASCII string "WB" without the string terminator.

\item[WBD\_VER\_MAJOR (Offset: 0x0E)] \hfill \\
The major version of the device descriptor format. This field is incompatible
between versions. This means that a change in the descriptor structure itself
leads to an increase in the major version. An example of a major version change
is the extension of HDL\_BASE and HDL\_SIZE to 16 bytes (128 bits).

\item[WBD\_VER\_MINOR (Offset: 0x0F)] \hfill \\
The minor version of the device descriptor format. This field is compatible
between versions. This means that a change only in the minor number means the
structure is preserved. An example of a minor version change is the addition
of a new flag in the WBD\_FLAGS field.

\item[HDL\_BASE (Offset: 0x10)] \hfill \\
This field contains the base address of the Wishbone device.
The software reading this field should know what address width to expect.

\item[HDL\_SIZE (Offset: 0x18)] \hfill \\
This field contains the size of the address space of this device.
The software reading this field should know what address width to expect.

\item[WBD\_FLAGS (Offset: 0x20)] \hfill \\
Currently undefined.

\item[HDL\_CLASS (Offset: 0x24)] \hfill \\
The class of the Wishbone device. The class is used to identify a device
with a specific register map, so a host driver can handle all devices of
the same class, irrespective of vendor and device numbers. This is similar
to PCI or USB devices.

\item[HDL\_VERSION (Offset: 0x28)] \hfill \\
This field specifies the version of the Wishbone device. The format can be
specified in any way by a vendor as the software reading this field will be
specific to each vendor (selected based on the metadata stored in the
parent board) and is expected to know how to decode this field.

\item[HDL\_DATE (Offset: 0x2C)] \hfill \\
The HDL date should be set to the hex-readable date of synthesis of
the Wishbone device. An example of a hex-readable date is 0x20111225 (25th
December 2011).

\item[VENDOR\_NAME (Offset: 0x30)] \hfill \\
The ASCII string representation of the vendor name. The unused bytes of the
string should be set to the value 0x20. The length of the ASCII string can range
up to the maximum size (16 characters).

\item[DEVICE\_NAME (Offset: 0x40)] \hfill \\
The ASCII string representation of the device name. The unused bytes of the
string should be set to the value 0x20. The length of the ASCII string can range
up to the maximum size (16 characters).
\end{description}

\subsubsection{Note on Vendor IDs}
The vendor ID values are taken from a 64 bit address space.
This space is divided into two sections; \emph{reserved} and \emph{free}.

The \emph{reserved} vendor space includes all values with the highest 
bit unset (0x0000000000000000 - 0x7FFFFFFFFFFFFFFF).

The \emph{free} vendor space includes all values with the highest 
bit set (0x8000000000000000 - 0xFFFFFFFFFFFFFFFF).

Vendors are free to choose any value within the free space. There is no
guarantee of collisions of ID's with other vendors within the free space.
In the future, there could possibly be a central repository that allows
for guaranteed vendor ID's within the reserved space. The current version
of the specification however, provides no guarantee of collisions within
the reserved space. If you wish to use ID's from the reserved space, you
might need to make modifications to your device in future version of this
specification.

It is recommended that the vendor ID be chosen using an established 
hashing algorithm by feeding it uniquely identifying fields. The
recommended fields to use are the vendor name string and a 128 bit random
seed. It is recommended to use the MD5 hash of these fields and take the
8 least significant bytes from the resulting hash.


\section{Example Memory Map}

Figure \ref{fig:wbmap} illustrates the
structure of the Wishbone memory map for a bitstream containing three Wishbone
devices. There is a single header block that has the addresses of the other
blocks. There is a single ID block containing metadata regarding the bitstream
along with a single device descriptor block containing descriptors for the three
devices present in the bitstream.

\begin{figure}[!ht]
	\centering
	\includegraphics{wbmap.eps}
	\caption{Example memory map of a Self-Describing Wishbone bus}
	\label{fig:wbmap}
\end{figure}

\end{document}
